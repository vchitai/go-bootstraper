package utils

import (
	"embed"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type Walker interface {
	Go() error
}

var _ Walker = Walkers{}
var _ Walker = &JohnyWalker{}

type Walkers []Walker

func (ws Walkers) Go() error {
	for _, w := range ws {
		if err := w.Go(); err != nil {
			return err
		}
	}
	return nil
}

// responsible for parsing all templates in the source folder to destination folder with provider parameter
// custom the destination file name with altName
type JohnyWalker struct {
	rootFS    embed.FS
	from      string
	to        string
	parameter map[string]interface{}
	altName   func(string) string
	override  bool
	force     bool
}

func NewWalker() *JohnyWalker {
	return &JohnyWalker{}
}

func (jw *JohnyWalker) clone() *JohnyWalker {
	return &JohnyWalker{
		rootFS:    jw.rootFS,
		from:      jw.from,
		to:        jw.to,
		parameter: jw.parameter,
		altName:   jw.altName,
		override:  jw.override,
	}
}

func (jw *JohnyWalker) WithFS(embedFS embed.FS) *JohnyWalker {
	newOne := jw.clone()
	newOne.rootFS = embedFS
	return newOne
}

func (jw *JohnyWalker) From(from string) *JohnyWalker {
	newOne := jw.clone()
	newOne.from = filepath.Join(newOne.from, from)
	return newOne
}

func (jw *JohnyWalker) To(to string) *JohnyWalker {
	newOne := jw.clone()
	newOne.to = filepath.Join(newOne.to, to)
	return newOne
}

func (jw *JohnyWalker) WithParams(params map[string]interface{}) *JohnyWalker {
	newOne := jw.clone()
	newOne.parameter = params
	return newOne
}

func (jw *JohnyWalker) AltName(altName func(string) string) *JohnyWalker {
	newOne := jw.clone()
	newOne.altName = altName
	return newOne
}
func (jw *JohnyWalker) Override(override bool) *JohnyWalker {
	newOne := jw.clone()
	newOne.override = override
	return newOne
}

func (jw *JohnyWalker) Force(force bool) *JohnyWalker {
	newOne := jw.clone()
	newOne.force = force
	return newOne
}

func (jw *JohnyWalker) meetDir(at string) error {
	des, err := jw.rootFS.ReadDir(filepath.Join(jw.from, at))
	if err != nil {
		return err
	}
	for _, de := range des {
		if err := jw.continueTravel(de, at); err != nil {
			return err
		}
	}
	return err
}

var defaultFileName = map[string]string{
	//"proto/proto_name_lower.proto.tmpl":               "proto/service.proto.tmpl",
	//"proto/proto_name_lower_message.proto.tmpl":       "proto/message.proto.tmpl",
	//"pkg/client/proto_name_lower.go.tmpl":             "pkg/client/client.go.tmpl",
	"internal/services/server_name_lower.go.tmpl":     "internal/services/service.go.tmpl",
	"internal/services/server_name_lower_gen.go.tmpl": "internal/services/service_gen.go.tmpl",
	"cmd/server/server_name_lower.go.tmpl":            "cmd/server/service.go.tmpl",
}

func (jw *JohnyWalker) meetFile(at string) error {
	currentFilePath := filepath.Join(jw.from, at)

	if _, ok := jw.parameter["Default"]; ok {
		if s, ok := defaultFileName[at]; ok {
			at = s
		}
	}

	dirPath, fileName := filepath.Split(at)

	if !strings.Contains(fileName, ".tmpl") {
		// current only support tmpl files.
		return nil
	}

	newFileName := strings.ReplaceAll(fileName, ".tmpl", "")
	for f, t := range jw.parameter {
		switch ts := t.(type) {
		case string:
			newFileName = strings.ReplaceAll(newFileName, f, ts)
		}
	}

	newFileName = strings.ReplaceAll(newFileName, "dot@", ".")

	newFilePath := filepath.Join(jw.to, dirPath, newFileName)
	newDirPath := filepath.Join(jw.to, dirPath)

	err := os.MkdirAll(newDirPath, os.ModePerm)
	if err != nil {
		return err
	}
	if _, err := os.Stat(newFilePath); !os.IsNotExist(err) {
		if jw.force || (jw.override && strings.Contains(newFileName, "_gen")) {
			log.Printf("update %s", newFilePath)
		} else {
			return err
		}
	} else {
		log.Printf("generate %s", newFilePath)
	}
	_, err = os.Create(newFilePath)
	if err != nil {
		return err
	}
	fo, err := os.OpenFile(newFilePath, os.O_WRONLY, os.ModePerm)
	if err != nil {
		return err
	}
	if strings.Contains(newFileName, "_gen") {
		fo.WriteString("// Code generated by go-bootstrapper. DO NOT EDIT.\n")
	} else if strings.HasSuffix(newFileName, ".go") {
		fo.WriteString("// Code generated by go-bootstrapper. YOU CAN EDIT.\n")
	}
	tmpl, err := template.ParseFS(jw.rootFS, currentFilePath)
	if err != nil {
		return err
	}
	err = tmpl.Execute(fo, jw.parameter)
	if err != nil {
		return err
	}

	return nil
}

func (jw *JohnyWalker) continueTravel(current fs.DirEntry, travelPath string) error {
	if current == nil {
		return nil
	}
	if current.IsDir() {
		return jw.meetDir(filepath.Join(travelPath, current.Name()))
	} else {
		return jw.meetFile(filepath.Join(travelPath, current.Name()))
	}
}

func (jw *JohnyWalker) Go() error {
	// discover the root first, the travelPath is at the root
	return jw.meetDir("")
}
